<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>清风徐来！只为努力归来的少年</title>
  
  <subtitle>只为遇到更好的自己</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-10T03:04:17.440Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Anne-jia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dav</title>
    <link href="http://yoursite.com/Protfolio/Portfolio/dav/"/>
    <id>http://yoursite.com/Protfolio/Portfolio/dav/</id>
    <published>2020-07-01T13:48:39.000Z</published>
    <updated>2020-07-10T03:04:17.440Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>dva是基于redux的框架不是插件<br>是基于redux,redux-saga的数据流方案支持热重载</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>6个api<br>dva 还额外内置了 react-router 和 fetch</p><p>mock（数据模拟）</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>命名：安装：npm install dva-cli -g<br>查看版本： dva -v<br>创建应用：dva new 应用名称<br>安装antd:npm install antd babel-plugin-import –save<br>babel-plugin-import (按需加载)<br>webpackrc配置文件：经常用到，配置ajax情求<br>路由：原理：有#号的是锚点定位<br>history:利用H5的history的API<br>学习：知识地图和API<br>UI component</p><p><a href="https://dvajs.com/guide/" target="_blank" rel="noopener">更多就去看官方文档吧！</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;dva是基于redux的框架不是插件&lt;br&gt;是基于redux,redux-saga的数据流方案支持热重载&lt;/p&gt;
&lt;h2 id=&quot;配置&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Protfolio" scheme="http://yoursite.com/categories/Protfolio/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是纯函数</title>
    <link href="http://yoursite.com/js/bj/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/js/bj/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0/</id>
    <published>2019-09-08T13:48:39.000Z</published>
    <updated>2020-07-10T02:23:54.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>对外界没有副作用的函数<br>同样的输入，得到同样的输出</p><p>不是纯函数的例子</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myname =<span class="string">'ll'</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>(){</span><br><span class="line">myname=<span class="string">'xx'</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">test</span>()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj ={myname:<span class="string">'ll'</span>}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(obj){</span><br><span class="line"> obj.myname=<span class="string">'xx'</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">test</span>(obj) 相当于同一把钥匙开同一个门</span><br></pre></td></tr></tbody></table></figure><p>纯函数的例子</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myname =<span class="string">'ll'</span></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(myname){</span><br><span class="line"> myname=<span class="string">'xx'</span></span><br><span class="line">}</span><br><span class="line">text(myname)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var obj ={myname:<span class="string">'ll'</span>}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="built_in">test</span>(obj){</span><br><span class="line">var newobj={...obj}</span><br><span class="line"> newobj.myname=<span class="string">'xx'</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="built_in">test</span>(obj)</span><br></pre></td></tr></tbody></table></figure><h1 id="应用中"><a href="#应用中" class="headerlink" title="应用中"></a>应用中</h1><p>react的高阶组件就是用到了纯函数的概念</p><p>用到的高阶组件 <code>withRoute connect reduct memo</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;对外界没有副作用的函数&lt;br&gt;同样的输入，得到同样的输出&lt;/p&gt;
&lt;p&gt;不是纯函数的例子&lt;/p&gt;
&lt;figure class=&quot;highli
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>粒子插件</title>
    <link href="http://yoursite.com/protfolio/Portfolio/%E7%B2%92%E5%AD%90%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/protfolio/Portfolio/%E7%B2%92%E5%AD%90%E6%8F%92%E4%BB%B6/</id>
    <published>2019-07-07T16:47:26.000Z</published>
    <updated>2020-07-10T03:33:06.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h3><p><code>react-particles-js</code><br>基于particles-js写的<br><code>canvas</code>画布已经画出来，改变背景可以显示<br><code>canvas</code>的背景高度更改 不支持百分比<br>可以设置为<code>window.innerHeight+'px'</code></p><p>不知道就去翻看文档咯！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用：&quot;&gt;&lt;a href=&quot;#使用：&quot; class=&quot;headerlink&quot; title=&quot;使用：&quot;&gt;&lt;/a&gt;使用：&lt;/h3&gt;&lt;p&gt;&lt;code&gt;react-particles-js&lt;/code&gt;&lt;br&gt;基于particles-js写的&lt;br&gt;&lt;code&gt;canva
      
    
    </summary>
    
    
      <category term="protfolio" scheme="http://yoursite.com/categories/protfolio/"/>
    
    
      <category term="protflio" scheme="http://yoursite.com/tags/protflio/"/>
    
  </entry>
  
  <entry>
    <title>ts基本类型</title>
    <link href="http://yoursite.com/protfolio/Portfolio/ts%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/protfolio/Portfolio/ts%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</id>
    <published>2019-06-07T17:47:26.000Z</published>
    <updated>2020-07-14T13:34:10.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ts基本类型"><a href="#ts基本类型" class="headerlink" title="ts基本类型"></a>ts基本类型</h2><table><thead><tr><th>数据类型</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>任意类型</td><td>any</td><td>声明为 any 的变量可以赋予任意类型的值。</td></tr><tr><td>数据类型</td><td>number</td><td>双精度 64 位浮点值。它可以用来表示整数和分数。</td></tr><tr><td>字符串类型</td><td>string</td><td>一个字符系列，使用单引号（’）或双引号（”）来表示字符串类型。<br>反引号（`）来定义多行文本和内嵌表达式。</td></tr><tr><td>布尔类型</td><td>boolean</td><td>表示逻辑值：true 和 false。</td></tr><tr><td>数组类型</td><td>无</td><td>声明变量为数组。<br>// 在元素类型后面加上[]<br><code>let arr: number[] = [1, 2];</code> <br>// 或者使用数组泛型<br><code>let arr: Array&lt;number&gt; = [1, 2];</code></td></tr><tr><td>元组</td><td>无</td><td>元组类型用来表示已知元素数量和类型的数组，<br>各元素的类型不必相同，<br>对应位置的类型需要相同。<br><code>let x: [string, number]; x = ['Runoob', 1];</code><br><code>// 运行正常 x = [1, 'Runoob'];   // 报错 console.log(x[0]);</code><br>   <code>// 输出 Runoob</code></td></tr><tr><td>枚举</td><td>enum</td><td>枚举类型用于定义数值集合。<br><code>enum Color {Red, Green, Blue};</code><br> <code>let c: Color = Color.Blue;console.log(c);    // 输出 2</code></td></tr><tr><td>void</td><td>void</td><td>用于标识方法返回值的类型，表示该方法没有返回值。</td></tr><tr><td>null</td><td>null</td><td>表示对象值缺失。</td></tr><tr><td>undefined</td><td>undefined</td><td>用于初始化变量为一个未定义的值</td></tr><tr><td>never</td><td>never</td><td>never 是其它类型（包括 null 和 undefined）的子类型，<br>代表从不会出现的值。</td></tr></tbody></table><h2 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a>Any 类型</h2><p>任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。</p><p>1、变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查，示例代码如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x: any = 1;    // 数字类型</span><br><span class="line">x = <span class="string">'I am who I am'</span>;    // 字符串类型</span><br><span class="line">x = <span class="literal">false</span>;    // 布尔类型</span><br></pre></td></tr></tbody></table></figure><p>2、改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查，示例代码如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x: any = 4;</span><br><span class="line">x.ifItExists();    // 正确，ifItExists方法在运行时可能存在，但这里并不会检查</span><br><span class="line">x.toFixed();    // 正确</span><br></pre></td></tr></tbody></table></figure><p>3、定义存储各种类型数据的数组时，示例代码如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arrayList: any[] = [1, <span class="literal">false</span>, <span class="string">'fine'</span>];</span><br><span class="line">arrayList[1] = 100;</span><br></pre></td></tr></tbody></table></figure><h3 id="never-类型"><a href="#never-类型" class="headerlink" title="never 类型"></a>never 类型</h3><p>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环），示例代码如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> x: never;</span><br><span class="line"><span class="built_in">let</span> y: number;</span><br><span class="line"></span><br><span class="line">// 运行错误，数字类型不能转为 never 类型</span><br><span class="line">x = 123;</span><br><span class="line"></span><br><span class="line">// 运行正确，never 类型可以赋值给 never类型</span><br><span class="line">x = (()=&gt;{ throw new Error(<span class="string">'exception'</span>)})();</span><br><span class="line"></span><br><span class="line">// 运行正确，never 类型可以赋值给 数字类型</span><br><span class="line">y = (()=&gt;{ throw new Error(<span class="string">'exception'</span>)})();</span><br><span class="line"></span><br><span class="line">// 返回值为 never 的函数可以是抛出异常的情况</span><br><span class="line"><span class="keyword">function</span> error(message: string): never {</span><br><span class="line">    throw new Error(message);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span><br><span class="line"><span class="keyword">function</span> loop(): never {</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul><li>访问元组 (下标)</li><li>元组运算 push()最后面添加  pop() 移除最后一个</li><li>更新元组 对应下标赋值</li><li>结构元组 <code>var a =[10,"Runoob"] var [b,c] = a console.log(b) ; console.log(c)</code></li></ul><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><ul><li>可以通过管道<code>|</code>将变量设置多种类型，赋值时可以根据设置的类型来赋值<code>(Type1|Type2|Type3 )</code></li><li>数组声明为联合类型 <code>var arr:number[]|string[]</code>; <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var arr:number[]|string[]; </span><br><span class="line">var i:number; </span><br><span class="line">arr = [1,2,4] </span><br><span class="line">console.log(<span class="string">"**数字数组**"</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = 0;i&lt;arr.length;i++) { </span><br><span class="line">   console.log(arr[i]) </span><br><span class="line">}  </span><br><span class="line"> </span><br><span class="line">arr = [<span class="string">"Runoob"</span>,<span class="string">"Google"</span>,<span class="string">"Taobao"</span>] </span><br><span class="line">console.log(<span class="string">"**字符串数组**"</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = 0;i&lt;arr.length;i++) { </span><br><span class="line">   console.log(arr[i]) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量作用域指定了变量定义的位置。</p><p>程序中变量的可用性由变量作用域决定。</p><p>TypeScript 有以下几种作用域：</p><ul><li><p>全局作用域 − 全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。</p></li><li><p>类作用域 − 这个变量也可以称为 字段。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。</p></li><li><p>局部作用域 − 局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var global_num = 12          // 全局变量</span><br><span class="line">class Numbers { </span><br><span class="line">   num_val = 13;             // 实例变量</span><br><span class="line">   static sval = 10;         // 静态变量</span><br><span class="line">   </span><br><span class="line">   storeNum():void { </span><br><span class="line">      var local_num = 14;    // 局部变量</span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line">console.log(<span class="string">"全局变量为: "</span>+global_num)  </span><br><span class="line">console.log(Numbers.sval)   // 静态变量</span><br><span class="line">var obj = new Numbers(); </span><br><span class="line">console.log(<span class="string">"实例变量: "</span>+obj.num_val)</span><br></pre></td></tr></tbody></table></figure><p>js代码</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var global_num = 12; // 全局变量</span><br><span class="line">var Numbers = /** @class */ (<span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">Numbers</span></span>() {</span><br><span class="line">        this.num_val = 13; // 实例变量</span><br><span class="line">    }</span><br><span class="line">    Numbers.prototype.storeNum = <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">        var local_num = 14; // 局部变量</span><br><span class="line">    };</span><br><span class="line">    Numbers.sval = 10; // 静态变量</span><br><span class="line">    <span class="built_in">return</span> Numbers;</span><br><span class="line">}());</span><br><span class="line">console.log(<span class="string">"全局变量为: "</span> + global_num);</span><br><span class="line">console.log(Numbers.sval); // 静态变量</span><br><span class="line">var obj = new Numbers();</span><br><span class="line">console.log(<span class="string">"实例变量: "</span> + obj.num_val);</span><br></pre></td></tr></tbody></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2></li><li><p>算数运算符</p></li><li><p>逻辑运算符</p></li><li><p>关系运算符</p></li><li><p>按位运算符</p></li><li><p>赋值运算符</p></li><li><p>三元/条件运算符</p></li><li><p>字符串运算符</p></li><li><p>类型运算符(typeof)</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2></li><li><p>if 语句 - 只有当指定条件为 true 时，使用该语句来执行代码</p></li><li><p>if…else 语句 - 当条件为 true 时执行代码，当条件为 false 时执行其他代码</p></li><li><p>if…else if….else 语句- 使用该语句来选择多个代码块之一来执行</p></li><li><p>switch 语句 - 使用该语句来选择多个代码块之一来执行</p></li></ul><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><ul><li>for 循环</li><li>for…in 语句用于一组值的集合或列表进行迭代输出。</li><li>for…of 语句创建一个循环来迭代可迭代的对象(for…of 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。)</li><li>forEach、every 和 some 是 JavaScript 的循环语法</li><li>while 循环</li><li>do…while 循环</li><li>break 语句<br>  1、当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。<br>  2、 它可用于终止 switch 语句中的一个 case。</li><li>continue 语句执行后自增语句仍然会执行。对于 while 和 do…while 循环，continue 语句重新执行条件判断语句</li><li>无限循环 <ul><li>for 创建 <code>for(;;){语句}</code></li><li>while 创建 <code>while(true){语句}</code></li></ul></li></ul><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> list = [4, 5, 6];</span><br><span class="line">list.forEach((val, idx, array) =&gt; {</span><br><span class="line">    // val: 当前值</span><br><span class="line">    // idx：当前index</span><br><span class="line">    // array: Array</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> list = [4, 5, 6];</span><br><span class="line">list.every((val, idx, array) =&gt; {</span><br><span class="line">    // val: 当前值</span><br><span class="line">    // idx：当前index</span><br><span class="line">    // array: Array</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>; // Continues</span><br><span class="line">    // Return <span class="literal">false</span> will quit the iteration</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>函数调用 <code>function_name()</code></p></li><li><p>函数返回值<br>  函数定义的时候需要定义返回值类型 <code>function name: type(){ return}</code></p></li><li><p>函数参数</p><ul><li><p>函数发送多个参数，每个参数使用逗号 <code>,</code> 分隔</p></li><li><p>可选参数  <font color="red">使用问号标识 ？可选参数必须跟在必需参数后面</font></p></li><li><p>默认参数 如果不传入该参数的值，则使用默认参数</p><p><font color="red"><em>参数不能同时设置为可选和默认</em></font></p></li><li><p>剩余参数  我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义  函数的最后一个命名参数 restOfName 以 … 为前缀</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> func_name( param1 [:datatype], param2 [:datatype]) {   </span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p>匿名函数  </p><ul><li>匿名函数是一个没有函数名的函数。</li><li>匿名函数自调用在函数后使用 () </li></ul></li><li><p>构造函数  <code>var res = new Function( [arguments] ) { ... })</code></p></li><li><p>递归函数 递归函数即在函数内调用函数本身。</p></li><li><p>箭头函数</p></li><li><p>函数重载 </p><ul><li>重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。</li><li>如果参数类型不同，则参数类型应设置为 any。</li><li>参数数量不同你可以将不同的参数设置为可选。<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2></li></ul></li><li><p>定义 (接口不能转换成js对象)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface interface_name { </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>接口中联合类型</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface RunOptions { </span><br><span class="line">    program:string; </span><br><span class="line">    commandline:string[]|string|(()=&gt;string); </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line">// commandline 是字符串</span><br><span class="line">var options:RunOptions = {program:<span class="string">"test1"</span>,commandline:<span class="string">"Hello"</span>}; </span><br><span class="line">console.log(options.commandline)  </span><br><span class="line"> </span><br><span class="line">// commandline 是字符串数组</span><br><span class="line">options = {program:<span class="string">"test1"</span>,commandline:[<span class="string">"Hello"</span>,<span class="string">"World"</span>]}; </span><br><span class="line">console.log(options.commandline[0]); </span><br><span class="line">console.log(options.commandline[1]);  </span><br><span class="line"> </span><br><span class="line">// commandline 是一个函数表达式</span><br><span class="line">options = {program:<span class="string">"test1"</span>,commandline:()=&gt;{<span class="built_in">return</span> <span class="string">"**Hello World**"</span>;}}; </span><br><span class="line"> </span><br><span class="line">var fn:any = options.commandline; </span><br><span class="line">console.log(fn());</span><br></pre></td></tr></tbody></table></figure></li><li><p>接口中的数组<br>将数组的索引值和元素设置为不同类型，索引值可以是数字或字符串。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface namelist { </span><br><span class="line">   [index:number]:string </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line">var list2:namelist = [<span class="string">"John"</span>,1,<span class="string">"Bran"</span>] / 错误元素 1 不是 string 类型</span><br><span class="line">interface ages { </span><br><span class="line">   [index:string]:number </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line">var agelist:ages; </span><br><span class="line">agelist[<span class="string">"John"</span>] = 15   // 正确 </span><br><span class="line">agelist[2] = <span class="string">"nine"</span>   // 错误</span><br></pre></td></tr></tbody></table></figure></li><li><p>接口继承<br>ts允许接口继承多个接口。<br>继承使用关键字 extends。<br>格式：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child_interface_name extends super_interface_name</span><br></pre></td></tr></tbody></table></figure><p>对继承用<code>,</code>隔开</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Child_interface_name extends super_interface1_name, super_interface2_name,…,super_interfaceN_name</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><p>字段 字段是类里面声明的变量。字段表示对象的有关数据。</p></li><li><p>构造函数  类实例化时调用，可以为类的对象分配内存。</p></li><li><p>方法 是对象要执行的操作</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Car { </span><br><span class="line">   // 字段</span><br><span class="line">   engine:string; </span><br><span class="line">   </span><br><span class="line">   // 构造函数</span><br><span class="line">   constructor(engine:string) { </span><br><span class="line">      this.engine = engine </span><br><span class="line">   }  </span><br><span class="line">   </span><br><span class="line">   // 方法</span><br><span class="line">   disp():void { </span><br><span class="line">      console.log(<span class="string">"函数中显示发动机型号  :   "</span>+this.engine) </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line">// 创建一个对象</span><br><span class="line">var obj = new Car(<span class="string">"XXSY1"</span>)</span><br><span class="line"> </span><br><span class="line">// 访问字段</span><br><span class="line">console.log(<span class="string">"读取发动机型号 :  "</span>+obj.engine)  </span><br><span class="line"> </span><br><span class="line">// 访问方法</span><br><span class="line">obj.disp()</span><br></pre></td></tr></tbody></table></figure><p>js代码</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var Car = /** @class */ (<span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    // 构造函数</span><br><span class="line">    <span class="keyword">function</span> Car(engine) {</span><br><span class="line">        this.engine = engine;</span><br><span class="line">    }</span><br><span class="line">    // 方法</span><br><span class="line">    Car.prototype.disp = <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">        console.log(<span class="string">"函数中显示发动机型号  :   "</span> + this.engine);</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">return</span> Car;</span><br><span class="line">}());</span><br><span class="line">// 创建一个对象</span><br><span class="line">var obj = new Car(<span class="string">"XXSY1"</span>);</span><br><span class="line">// 访问字段</span><br><span class="line">console.log(<span class="string">"读取发动机型号 :  "</span> + obj.engine);</span><br><span class="line">// 访问方法</span><br><span class="line">obj.disp();</span><br></pre></td></tr></tbody></table></figure><h3 id="类继承extends"><a href="#类继承extends" class="headerlink" title="类继承extends"></a>类继承extends</h3><p>TypeScript 一次只能继承一个类，不支持继承多个类，但 TypeScript 支持多重继承（A 继承 B，B 继承 C）。</p><h3 id="方法重新"><a href="#方法重新" class="headerlink" title="方法重新"></a>方法重新</h3><p>类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class PrinterClass { </span><br><span class="line">   doPrint():void {</span><br><span class="line">      console.log(<span class="string">"父类的 doPrint() 方法。"</span>) </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line">class StringPrinter extends PrinterClass { </span><br><span class="line">   doPrint():void { </span><br><span class="line">      super.doPrint() // 调用父类的函数</span><br><span class="line">      console.log(<span class="string">"子类的 doPrint()方法。"</span>)</span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>static 关键字用于定义类的数据成员（属性和方法）为静态的，静态成员可以直接通过类名调用。</p><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p>instanceof 运算符用于判断对象是否是指定的类型，如果是返回 true，否则返回 false。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person{ } </span><br><span class="line">var obj = new Person() </span><br><span class="line">var isPerson = obj instanceof Person; </span><br><span class="line">console.log(<span class="string">"obj 对象是 Person 类实例化来的吗？ "</span> + isPerson);</span><br></pre></td></tr></tbody></table></figure><h3 id="访问控制修饰符-3种"><a href="#访问控制修饰符-3种" class="headerlink" title="访问控制修饰符 3种"></a>访问控制修饰符 3种</h3></li><li><p>public（默认） 公用 可以在任何地方被访问。</p></li><li><p>protected 受保护 可以被其自身以及其子类和父类访问。</p></li><li><p>private :私有 只能被其定义所在的类访问。</p></li></ul><h3 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h3><p>类可以实现接口，使用关键字 implements，并将 interest 字段作为类的属性使用。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface ILoan { </span><br><span class="line">   interest:number </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line">class AgriLoan implements ILoan { </span><br><span class="line">   interest:number </span><br><span class="line">   rebate:number </span><br><span class="line">   </span><br><span class="line">   constructor(interest:number,rebate:number) { </span><br><span class="line">      this.interest = interest </span><br><span class="line">      this.rebate = rebate </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line"> </span><br><span class="line">var obj = new AgriLoan(10,1) </span><br><span class="line">console.log(<span class="string">"利润为 : "</span>+obj.interest+<span class="string">"，抽成为 : "</span>+obj.rebate )</span><br></pre></td></tr></tbody></table></figure><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>对象是包含一组键值对的实例。 值可以是标量、函数、数组、对象等</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var object_name = { </span><br><span class="line">    key1: <span class="string">"value1"</span>, // 标量</span><br><span class="line">    key2: <span class="string">"value"</span>,  </span><br><span class="line">    key3: <span class="function"><span class="title">function</span></span>() {</span><br><span class="line">        // 函数</span><br><span class="line">    }, </span><br><span class="line">    key4:[<span class="string">"content1"</span>, <span class="string">"content2"</span>] //集合</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>类型模板</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> var sites = {</span><br><span class="line">    site1: <span class="string">"Runoob"</span>,</span><br><span class="line">    site2: <span class="string">"Google"</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="title">function</span></span> () { } // 类型模板</span><br><span class="line">};</span><br><span class="line">sites.sayHello = <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    console.log(<span class="string">"hello "</span> + sites.site1);</span><br><span class="line">};</span><br><span class="line">sites.sayHello();</span><br></pre></td></tr></tbody></table></figure><p>js</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> var sites = {</span><br><span class="line">    site1: <span class="string">"Runoob"</span>,</span><br><span class="line">    site2: <span class="string">"Google"</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="title">function</span></span> () { } // 类型模板</span><br><span class="line">};</span><br><span class="line">sites.sayHello = <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    console.log(<span class="string">"hello "</span> + sites.site1);</span><br><span class="line">};</span><br><span class="line">sites.sayHello();</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间使用 <code>namespace</code> 来定义</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace SomeNameSpaceName { </span><br><span class="line">   export interface ISomeInterfaceName {      }  </span><br><span class="line">   export class SomeClassName {      }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>引用：<br><code>SomeNameSpaceName.SomeClassName;</code><br>单独的ts 使用<code>///</code><br><code>/// &lt;reference path = "SomeFileName.ts" /&gt;</code></p><h4 id="命名空间支持嵌套，即你可以将命名空间定义在另外一个命名空间里头。"><a href="#命名空间支持嵌套，即你可以将命名空间定义在另外一个命名空间里头。" class="headerlink" title="命名空间支持嵌套，即你可以将命名空间定义在另外一个命名空间里头。"></a>命名空间支持嵌套，即你可以将命名空间定义在另外一个命名空间里头。</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">namespace namespace_name1 { </span><br><span class="line">    export namespace namespace_name2 {</span><br><span class="line">        export class class_name {    } </span><br><span class="line">    } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>成员的访问使用点号 <code>.</code>来实现，如下实例<br>Invoice.ts 文件代码：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace Runoob { </span><br><span class="line">   export namespace invoiceApp { </span><br><span class="line">      export class Invoice { </span><br><span class="line">         public calculateDiscount(price: number) { </span><br><span class="line">            return price * .40; </span><br><span class="line">         } </span><br><span class="line">      } </span><br><span class="line">   } </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>InvoiceTest.ts 文件代码</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference path = "Invoice.ts" /&gt;</span><br><span class="line">var invoice = new Runoob.invoiceApp.Invoice(); </span><br><span class="line">console.log(invoice.calculateDiscount(500));</span><br></pre></td></tr></tbody></table></figure><p>编译</p><p><code>tsc --out app.js InvoiceTest.ts</code></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><ul><li>declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eclare var jQuery: (selector: string) =&gt; any;</span><br><span class="line"></span><br><span class="line">jQuery('#foo')</span><br></pre></td></tr></tbody></table></figure>&lt;font color = ‘red&gt;declare 定义的类型只会用于编译时的检查，编译结果中会被删除。</li></ul><h3 id="声明文件-1"><a href="#声明文件-1" class="headerlink" title="声明文件"></a>声明文件</h3><ul><li><code>.d.ts</code>为后缀 <code>runoob.d.ts</code></li><li>语法格式<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare 定义的类型只会用于编译时的检查，编译结果中会被删除。</span><br></pre></td></tr></tbody></table></figure></li><li>引入<br><code>/// &lt;reference path = " runoob.d.ts" /&gt;</code></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ts基本类型&quot;&gt;&lt;a href=&quot;#ts基本类型&quot; class=&quot;headerlink&quot; title=&quot;ts基本类型&quot;&gt;&lt;/a&gt;ts基本类型&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;描述&lt;/t
      
    
    </summary>
    
    
      <category term="protfolio" scheme="http://yoursite.com/categories/protfolio/"/>
    
    
      <category term="protflio" scheme="http://yoursite.com/tags/protflio/"/>
    
  </entry>
  
  <entry>
    <title>服务器端如何启动json-server</title>
    <link href="http://yoursite.com/protfolio/Portfolio/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8json-server/"/>
    <id>http://yoursite.com/protfolio/Portfolio/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8json-server/</id>
    <published>2019-06-07T17:47:26.000Z</published>
    <updated>2020-07-14T08:34:18.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、直接启动json-server-全局安装即可；只能用于本地访问"><a href="#1、直接启动json-server-全局安装即可；只能用于本地访问" class="headerlink" title="1、直接启动json-server(全局安装即可；只能用于本地访问)"></a>1、直接启动json-server(全局安装即可；只能用于本地访问)</h2><p>前提条件都是已经安装json-server  <code>npm install -g json-server</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server --watch 文件名 --port  端口号</span><br></pre></td></tr></tbody></table></figure><h2 id="2-创建json-server-只能用于本地访问"><a href="#2-创建json-server-只能用于本地访问" class="headerlink" title="2 创建json-server(只能用于本地访问)"></a>2 创建json-server(只能用于本地访问)</h2><ul><li>初始化项目<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></tbody></table></figure></li><li>配置package.json<br>在 package.json 中的 scripts 属性中添加：<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"start"</span>: <span class="string">"json-server --watch db.json --port 8080"</span></span><br></pre></td></tr></tbody></table></figure></li><li>安装josn-server<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install json-server --save</span><br></pre></td></tr></tbody></table></figure></li><li>运行项目<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></tbody></table></figure>终端显示<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Resources</span><br><span class="line">http://localhost:8080/user</span><br><span class="line">http://localhost:8080/list</span><br><span class="line">http://localhost:8080/cart</span><br><span class="line"></span><br><span class="line">Home</span><br><span class="line">http://localhost:8080</span><br></pre></td></tr></tbody></table></figure><h2 id="3、将json-server部署到linux的服务器中-需要项目中局部安装；可以使用公网ip访问"><a href="#3、将json-server部署到linux的服务器中-需要项目中局部安装；可以使用公网ip访问" class="headerlink" title="3、将json-server部署到linux的服务器中(需要项目中局部安装；可以使用公网ip访问)"></a>3、将json-server部署到linux的服务器中(需要项目中局部安装；可以使用公网ip访问)</h2></li><li>linux 上安装node<ul><li>准备gcc 或者升级 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc+ gcc-c++</span><br><span class="line">yum -y update gcc</span><br></pre></td></tr></tbody></table></figure><font color="red"> 不安装gcc会导致编译阶段不成功</font><ul><li>下载 node（注意在root下面操作）<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入 src目录下：<span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/</span><br><span class="line">wget http://nodejs.org/dist/v10.15.0/node-v10.15.0.tar.gz</span><br></pre></td></tr></tbody></table></figure></li><li>解压<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf node-v10.15.0.tar.gz</span><br></pre></td></tr></tbody></table></figure></li><li>编译<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></tbody></table></figure>等待时间会比较长。。。。</li><li>安装<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></tbody></table></figure></li><li>配置 配置NODE_HOME，进入profile编辑环境变量<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></tbody></table></figure></li><li>设置 nodejs 环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容:<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#set for nodejs</span></span><br><span class="line"><span class="built_in">export</span> NODE_HOME=/usr/<span class="built_in">local</span>/node/10.15.0(注意和安装的版本号一致)</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$NODE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></tbody></table></figure></li><li>:wq保存并退出，编译/etc/profile 使配置生效<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul></li></ul><p>安装成功查看版本（出现版本表示安装成功）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v </span><br><span class="line">cnpm -v</span><br></pre></td></tr></tbody></table></figure><ul><li><p>利用ftp 上传json之类文件到自定义的位置</p></li><li><p>启动项目</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></tbody></table></figure><p>出现结果有访问连接的说明是成功啦！<font color="red">注意此时只是本地可以访问，服务器上的网页在别处打开是无法访问到数据的</font></p></li><li><p>创建一个app.js</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const jsonServer = require(<span class="string">'json-server'</span>)</span><br><span class="line">const server = jsonServer.create()</span><br><span class="line">const router = jsonServer.router(<span class="string">'db.json'</span>)</span><br><span class="line">const middlewares = jsonServer.defaults()</span><br><span class="line"></span><br><span class="line">server.use(middlewares)</span><br><span class="line"></span><br><span class="line">server.get(<span class="string">'/echo'</span>, (req, res) =&gt; {</span><br><span class="line">  res.jsonp(req.query)</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">server.use(jsonServer.bodyParser)</span><br><span class="line">server.use((req, res, next) =&gt; {</span><br><span class="line">  <span class="keyword">if</span> (req.method === <span class="string">'POST'</span>) {</span><br><span class="line">    req.body.createdAt = Date.now()</span><br><span class="line">  }</span><br><span class="line">  next()</span><br><span class="line">})</span><br><span class="line"></span><br><span class="line">server.use(router)</span><br><span class="line">server.listen(8000, () =&gt; {</span><br><span class="line">  console.log(<span class="string">'JSON Server is running'</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure></li><li><p>启动方式为<code>node app.js</code></p></li></ul><h2 id="使得服务在Ctrl-c的状态下不关闭forever"><a href="#使得服务在Ctrl-c的状态下不关闭forever" class="headerlink" title="使得服务在Ctrl+c的状态下不关闭forever"></a>使得服务在<code>Ctrl+c</code>的状态下不关闭forever</h2><ul><li>全局安装<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g forever</span><br></pre></td></tr></tbody></table></figure></li><li>配置环境变量<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></tbody></table></figure></li><li>在 PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL后面添加<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set for forever</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/node-v8.11.4/lib/node_modules/forever/bin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/node-v8.11.4/bin</span><br></pre></td></tr></tbody></table></figure></li><li><code>:wq</code>退出保存  </li><li>刷新配置 <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soure/ect/profile</span><br></pre></td></tr></tbody></table></figure></li><li>查看版本号<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forever --version</span><br></pre></td></tr></tbody></table></figure></li><li>启动服务<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forever start app.js</span><br></pre></td></tr></tbody></table></figure></li><li>查看当前的forever启动目录<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forever list</span><br></pre></td></tr></tbody></table></figure></li><li>停止服务<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forever stop [pid]</span><br></pre></td></tr></tbody></table></figure></li><li>停止所有服务<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forever stopall</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、直接启动json-server-全局安装即可；只能用于本地访问&quot;&gt;&lt;a href=&quot;#1、直接启动json-server-全局安装即可；只能用于本地访问&quot; class=&quot;headerlink&quot; title=&quot;1、直接启动json-server(全局安装即可；只
      
    
    </summary>
    
    
      <category term="protfolio" scheme="http://yoursite.com/categories/protfolio/"/>
    
    
      <category term="protflio" scheme="http://yoursite.com/tags/protflio/"/>
    
  </entry>
  
  <entry>
    <title>项目依赖</title>
    <link href="http://yoursite.com/protfolio/Portfolio/%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C/"/>
    <id>http://yoursite.com/protfolio/Portfolio/%E9%94%99%E8%AF%AF%E8%BE%B9%E7%95%8C/</id>
    <published>2019-06-07T17:47:26.000Z</published>
    <updated>2020-07-16T11:39:21.971Z</updated>
    
    <content type="html"><![CDATA[<p>前端开发配置：<br>react-redux redux  redux-thunk redux-promise<br>路由<br>react-router-dom</p><p>react-logger react-devtools-extension  dev环境下</p><p>npm install –save-dev redux-devtools</p><p>后端环境搭建 server文件加下<br>npm init 初始化<br>express框架 koa2都可以<br>依照express为例子<br>cnpm install –save express<br>启动：node 名称.js<br>node express的实时刷新<br>全局安装：<br>npm i nodemon -g<br> 在项目中安装nodemon<br>npm i nodemon </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端开发配置：&lt;br&gt;react-redux redux  redux-thunk redux-promise&lt;br&gt;路由&lt;br&gt;react-router-dom&lt;/p&gt;
&lt;p&gt;react-logger react-devtools-extension  dev环境下&lt;/p
      
    
    </summary>
    
    
      <category term="protfolio" scheme="http://yoursite.com/categories/protfolio/"/>
    
    
      <category term="protflio" scheme="http://yoursite.com/tags/protflio/"/>
    
  </entry>
  
  <entry>
    <title>typescript</title>
    <link href="http://yoursite.com/protfolio/Portfolio/typescript/"/>
    <id>http://yoursite.com/protfolio/Portfolio/typescript/</id>
    <published>2019-06-07T16:47:26.000Z</published>
    <updated>2020-07-14T02:39:38.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Typescript"><a href="#安装Typescript" class="headerlink" title="安装Typescript"></a>安装Typescript</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></tbody></table></figure><p>查看版本：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></tbody></table></figure><p>创建文件为<code>.ts</code>后缀的<code>test.ts</code></p><p>执行命令 将TypeScript转换成javaScript</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc test.ts</span><br></pre></td></tr></tbody></table></figure><p>同时编译多个文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc file1.ts file2.ts file3.ts</span><br></pre></td></tr></tbody></table></figure><p>会在同级目录下看到<code>test.js</code>的文件</p><p>node 命令执行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js</span><br></pre></td></tr></tbody></table></figure><p>转换过程<br><img src="/img/protflio/ts.png" alt="avatar"></p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li>模块</li><li>函数</li><li>变量</li><li>语句和表达式</li><li>注释</li></ul><h2 id="ts常见的编译参数"><a href="#ts常见的编译参数" class="headerlink" title="ts常见的编译参数"></a>ts常见的编译参数</h2><table><thead><tr><th>序号</th><th>编译参数说明</th></tr></thead><tbody><tr><td></td><td>–help 显示帮助信息</td></tr><tr><td></td><td>–module载入扩展模块</td></tr><tr><td></td><td>–target 设置ECMA版本</td></tr><tr><td></td><td>–declaration 额外生成一个 .d.ts 扩展名的文件  <br><code>tsc ts-hw.ts --declaration</code> <br>以上命令会生成 ts-hw.d.ts、ts-hw.js 两个文件。</td></tr><tr><td></td><td>–removeComments 删除文件的注释</td></tr><tr><td></td><td>–out 多个输出合并成一个输出的文件</td></tr><tr><td></td><td>–sourcemap  sourcemap 是一个存储源代码与编译代码对应位置映射的信息文件。 生成<code>.map</code>的文件</td></tr><tr><td></td><td>–module noImplicitAny 在表达式和声明上有隐含的 any 类型时报错</td></tr><tr><td></td><td>–watch 在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。</td></tr></tbody></table><h2 id="空白和换行"><a href="#空白和换行" class="headerlink" title="空白和换行"></a>空白和换行</h2><p>ts会忽略程序中出现的空格，制表符和换行符</p><p><em>Ts区分大小写</em><br><strong>分号可选，可写可不写</strong></p><h2 id="ts注释"><a href="#ts注释" class="headerlink" title="ts注释"></a>ts注释</h2><ul><li>单行注释 ( // ) − 在 // 后面的文字都是注释内容。</li><li>多行注释 (/* */) − 这种注释可以跨越多行</li></ul><h2 id="ts面向对象的编程"><a href="#ts面向对象的编程" class="headerlink" title="ts面向对象的编程"></a>ts面向对象的编程</h2><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Site { </span><br><span class="line">   name():void { </span><br><span class="line">      console.log(<span class="string">"Runoob"</span>) </span><br><span class="line">   } </span><br><span class="line">} </span><br><span class="line">var obj = new Site(); </span><br><span class="line">obj.name();</span><br></pre></td></tr></tbody></table></figure><p>转换成js</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Site = /** @class */ (<span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">Site</span></span>() {</span><br><span class="line">    }</span><br><span class="line">    Site.prototype.name = <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">        console.log(<span class="string">"Runoob"</span>);</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">return</span> Site;</span><br><span class="line">}());</span><br><span class="line">var obj = new Site();</span><br><span class="line">obj.name();</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Typescript&quot;&gt;&lt;a href=&quot;#安装Typescript&quot; class=&quot;headerlink&quot; title=&quot;安装Typescript&quot;&gt;&lt;/a&gt;安装Typescript&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;t
      
    
    </summary>
    
    
      <category term="protfolio" scheme="http://yoursite.com/categories/protfolio/"/>
    
    
      <category term="protflio" scheme="http://yoursite.com/tags/protflio/"/>
    
  </entry>
  
  <entry>
    <title>富文本</title>
    <link href="http://yoursite.com/Protfolio/Portfolio/%E5%AF%8C%E6%96%87%E6%9C%AC/"/>
    <id>http://yoursite.com/Protfolio/Portfolio/%E5%AF%8C%E6%96%87%E6%9C%AC/</id>
    <published>2018-12-08T13:48:39.000Z</published>
    <updated>2020-07-10T02:56:41.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="draft-js-原生"><a href="#draft-js-原生" class="headerlink" title="draft-js 原生"></a>draft-js 原生</h3><p>说明：react-draft-wysiwyg 基于react<br>1、安装插件：react-draft-wysiwyg draft-js draftjs-to-html</p><p>2、引入：Editor  from ‘react-draft-wyswyg’</p><p>3、darftjs-to-html  将富文本转换成html存入到数据库</p><p>4、读取的时候html-to-draftjs 将html转换成富文本</p><pre><code class="bash">editorState:<span class="string">""</span>, //同步编辑器状态       contentState:<span class="string">""</span>//同步内容</code></pre><pre><code class="bash">onEditorStateChange={this.onEditorStateChange}//状态改变的时候就会改变值</code></pre><pre><code class="bash">onContentStateChange={this.onContentStateChange} //编辑框的内容</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;draft-js-原生&quot;&gt;&lt;a href=&quot;#draft-js-原生&quot; class=&quot;headerlink&quot; title=&quot;draft-js 原生&quot;&gt;&lt;/a&gt;draft-js 原生&lt;/h3&gt;&lt;p&gt;说明：react-draft-wysiwyg 基于react&lt;br&gt;
      
    
    </summary>
    
    
      <category term="Protfolio" scheme="http://yoursite.com/categories/Protfolio/"/>
    
    
  </entry>
  
  <entry>
    <title>思路</title>
    <link href="http://yoursite.com/Protfolio/Portfolio/%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/Protfolio/Portfolio/%E6%80%9D%E8%B7%AF/</id>
    <published>2018-12-08T13:48:39.000Z</published>
    <updated>2020-07-10T03:00:03.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><pre><code>路由设置引入组件库组件拆分成小的组件那段复用就引入那个实现具体功能引入数据库内容 mock</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;路由设置
引入组件库
组件拆分成小的组件
那段复用就引入那个
实现具体功能
引入数据库内容 mock&lt;/code&gt;&lt;/pre
      
    
    </summary>
    
    
      <category term="Protfolio" scheme="http://yoursite.com/categories/Protfolio/"/>
    
    
  </entry>
  
  <entry>
    <title>Webpack的配置</title>
    <link href="http://yoursite.com/webapck/webpacks/webpack%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/webapck/webpacks/webpack%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2018-12-08T13:48:39.000Z</published>
    <updated>2020-07-10T02:59:06.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="webpack配置的4大核心配置：入口-出口-loader-插件"><a href="#webpack配置的4大核心配置：入口-出口-loader-插件" class="headerlink" title="webpack配置的4大核心配置：入口  出口  loader  插件"></a>webpack配置的4大核心配置：入口  出口  loader  插件</h2><p>入口文件的更改：diy入口文件不仅仅是<code>index.js</code>文件<br>1、配置<code>webpack.config.js</code>文件<br>    写入的位置在文件的根目录下<br>2、必须有导出：</p><pre><code class="bash">module.exports={}</code></pre><p>3、入口和出口关键字是固定的</p><pre><code class="bash">module.exports={    // 入口    entry:{    },    // 出口    output:{    }}</code></pre><p>4、设置入口和出口</p><pre><code class="bash">module.exports={    // 入口    entry:{        // 绝对路径加相对路径 key值是不固定的        <span class="string">'kk'</span>:__dirname +<span class="string">'/src/main.js'</span>    },    // 出口    output:{        // 打包后的文件存放的地方        path : __dirname +<span class="string">'/dist'</span>,        // 打包后输出文件的文件名        filename:<span class="string">'aaa.js'</span>    }}</code></pre><p>5、多个入口：多个入口的原因可能是多页面应用或者是引入不同的js代码<br><code>dist</code>文件夹下的js文件会根据<code>name</code>的名字来显示，既生成：<code>kk.js kk2.js</code></p><pre><code class="bash">module.exports={    // 入口    entry:{        // 绝对路径加相对路径 key值是不固定的        <span class="string">'kk'</span>:__dirname +<span class="string">'/src/main.js'</span>,        <span class="string">'kk2'</span>:__dirname +<span class="string">'/src/main2.js'</span>    },    // 出口    output:{        // 打包后的文件存放的地方        path : __dirname +<span class="string">'/dist'</span>,        // 打包后输出文件的文件名        filename:<span class="string">'[name].js'</span>    }}</code></pre><h2 id="Webpack-性能优化"><a href="#Webpack-性能优化" class="headerlink" title="Webpack 性能优化"></a>Webpack 性能优化</h2><p>思考中： <code>有哪些方式可以减少 Webpack 的打包时间</code><br><code>有哪些方式可以让 Webpack 打出来的包更小</code></p><h3 id="减少-Webpack-打包时间"><a href="#减少-Webpack-打包时间" class="headerlink" title="减少 Webpack 打包时间"></a>减少 Webpack 打包时间</h3><h4 id="优化-Loader"><a href="#优化-Loader" class="headerlink" title="优化 Loader"></a>优化 Loader</h4><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。</p><p>首先我们可以优化 Loader 的文件搜索范围</p><pre><code class="bash">module.exports = {  module: {    rules: [      {        // js 文件才使用 babel        <span class="built_in">test</span>: /\.js$/,        loader: <span class="string">'babel-loader'</span>,        // 只在 src 文件夹下查找        include: [resolve(<span class="string">'src'</span>)],        // 不会去查找的路径        exclude: /node_modules/      }    ]  }}</code></pre><p>对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。</p><p>当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</p><pre><code class="bash">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></code></pre><h4 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h4><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><p>HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</p><pre><code class="bash">module: {  loaders: [    {      <span class="built_in">test</span>: /\.js$/,      include: [resolve(<span class="string">'src'</span>)],      exclude: /node_modules/,      // id 后面的内容对应下面      loader: <span class="string">'happypack/loader?id=happybabel'</span>    }  ]},plugins: [  new HappyPack({    id: <span class="string">'happybabel'</span>,    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],    // 开启 4 个线程    threads: 4  })]</code></pre><h4 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h4><p>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</p><p>接下来我们就来学习如何使用 DllPlugin</p><pre><code class="bash">// 单独配置在一个文件中// webpack.dll.conf.jsconst path = require(<span class="string">'path'</span>)const webpack = require(<span class="string">'webpack'</span>)module.exports = {  entry: {    // 想统一打包的类库    vendor: [<span class="string">'react'</span>]  },  output: {    path: path.join(__dirname, <span class="string">'dist'</span>),    filename: <span class="string">'[name].dll.js'</span>,    library: <span class="string">'[name]-[hash]'</span>  },  plugins: [    new webpack.DllPlugin({      // name 必须和 output.library 一致      name: <span class="string">'[name]-[hash]'</span>,      // 该属性需要与 DllReferencePlugin 中一致      context: __dirname,      path: path.join(__dirname, <span class="string">'dist'</span>, <span class="string">'[name]-manifest.json'</span>)    })  ]}</code></pre><p>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 DllReferencePlugin 将依赖文件引入项目中</p><pre><code class="bash">// webpack.conf.jsmodule.exports = {  // ...省略其他配置  plugins: [    new webpack.DllReferencePlugin({      context: __dirname,      // manifest 就是之前打包出来的 json 文件      manifest: require(<span class="string">'./dist/vendor-manifest.json'</span>),    })  ]}</code></pre><h4 id="代码压缩"><a href="#代码压缩" class="headerlink" title="代码压缩"></a>代码压缩</h4><p>在 Webpack3 中，我们一般使用 UglifyJS 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p><p>在 Webpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 console.log 这类代码的功能。</p><p>一些小的优化点<br>我们还可以通过一些小的优化点来加快打包速度</p><p><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>['.js', '.json']</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面<br><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径<br><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</p><h3 id="减少-Webpack-打包后的文件体积"><a href="#减少-Webpack-打包后的文件体积" class="headerlink" title="减少 Webpack 打包后的文件体积"></a>减少 Webpack 打包后的文件体积</h3><h4 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h4><p>想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p><p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code> 成功以后去执行回调。</p><h4 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h4><p>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p><p>比如我们希望打包两个文件</p><pre><code class="bash">// test.js<span class="built_in">export</span> const a = 1// index.jsimport { a } from <span class="string">'./test.js'</span></code></pre><p>对于这种情况，我们打包出来的代码会类似这样</p><pre><code class="bash">[  /* 0 */  <span class="keyword">function</span> (module, exports, require) {    //...  },  /* 1 */  <span class="keyword">function</span> (module, exports, require) {    //...  }]</code></pre><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><pre><code class="bash">[  /* 0 */  <span class="keyword">function</span> (module, exports, require) {    //...  }]</code></pre><p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 optimization.concatenateModules 就可以了。</p><pre><code class="bash">module.exports = {  optimization: {    concatenateModules: <span class="literal">true</span>  }}</code></pre><h4 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h4><p>Tree Shaking 可以实现删除项目中未被引用的代码，比如</p><pre><code class="bash">// test.js<span class="built_in">export</span> const a = 1<span class="built_in">export</span> const b = 2// index.jsimport { a } from <span class="string">'./test.js'</span></code></pre><p>对于以上情况，test 文件中的变量 b 如果没有在项目中使用到的话，就不会被打包到文件中。<br>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p><pre><code class="bash"></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;webpack配置的4大核心配置：入口-出口-loader-插件&quot;&gt;&lt;a href=&quot;#webpack配置的4大核心配置：入口-出口-loader-插件&quot; class=&quot;headerlink&quot; title=&quot;webpack配置的4大核心配置：入口  出口  loa
      
    
    </summary>
    
    
      <category term="webapck" scheme="http://yoursite.com/categories/webapck/"/>
    
    
  </entry>
  
  <entry>
    <title>模拟数据 mock服务器</title>
    <link href="http://yoursite.com/mock/mock/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%20mock%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/mock/mock/%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%20mock%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2018-12-08T13:48:39.000Z</published>
    <updated>2020-07-10T02:58:55.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h2><p>全局安装json-server</p><p>启动命令：json-server –watch ./test.json  –port  8000 </p><p>创建好假的json 文件</p><p>在json中定义几个key值就是多少个接口</p><p>json文件可以通过id访问每个接口的一部分</p><p>请求数据</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>有没有跨域限制<br>谁请求就允许谁进行请求</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;json-server&quot;&gt;&lt;a href=&quot;#json-server&quot; class=&quot;headerlink&quot; title=&quot;json-server&quot;&gt;&lt;/a&gt;json-server&lt;/h2&gt;&lt;p&gt;全局安装json-server&lt;/p&gt;
&lt;p&gt;启动命令：json-s
      
    
    </summary>
    
    
      <category term="mock" scheme="http://yoursite.com/categories/mock/"/>
    
    
  </entry>
  
  <entry>
    <title>路由跳转不好使</title>
    <link href="http://yoursite.com/protfolio/Portfolio/%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%A5%BD%E4%BD%BF/"/>
    <id>http://yoursite.com/protfolio/Portfolio/%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%A5%BD%E4%BD%BF/</id>
    <published>2018-12-07T16:47:26.000Z</published>
    <updated>2020-07-10T03:15:41.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原因：该组件没有背Route包裹"><a href="#原因：该组件没有背Route包裹" class="headerlink" title="原因：该组件没有背Route包裹"></a>原因：该组件没有背Route包裹</h3><p>Route渲染的时候使用的render 不是component<br><code>&lt;Route path='' render ={(props)=&gt;&lt;List {...props}&gt;&lt;/List&gt;}&gt;&lt;/Route&gt;</code> 需要传参</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>将父元素的属性传给子元素</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SideMenu kkhistory={this.props.history}&gt;&lt;/SideMenu&gt;</span><br></pre></td></tr></tbody></table></figure><pre><code>调用父传的属性</code></pre><pre><code class="bash">this.props.kkhistory.push(obj.key)</code></pre><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><pre><code>withRouter 高阶组件 获取低阶组件，生成高阶组件    组件导出的时候用withRouter包裹</code></pre><pre><code class="bash"><span class="built_in">export</span> default withRouter(SideMune)使用this.props.history.push(<span class="string">''</span>) </code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原因：该组件没有背Route包裹&quot;&gt;&lt;a href=&quot;#原因：该组件没有背Route包裹&quot; class=&quot;headerlink&quot; title=&quot;原因：该组件没有背Route包裹&quot;&gt;&lt;/a&gt;原因：该组件没有背Route包裹&lt;/h3&gt;&lt;p&gt;Route渲染的时候使用的r
      
    
    </summary>
    
    
      <category term="protfolio" scheme="http://yoursite.com/categories/protfolio/"/>
    
    
      <category term="protflio" scheme="http://yoursite.com/tags/protflio/"/>
    
  </entry>
  
  <entry>
    <title>权限如何划分</title>
    <link href="http://yoursite.com/protfolio/Portfolio/%E6%9D%83%E9%99%90%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86/"/>
    <id>http://yoursite.com/protfolio/Portfolio/%E6%9D%83%E9%99%90%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86/</id>
    <published>2018-11-07T16:47:26.000Z</published>
    <updated>2020-07-10T03:18:28.053Z</updated>
    
    <content type="html"><![CDATA[<p>设置好每个功能项权限的级别<br>对请求的用户数据存储到loaclStorage<br>根据用户的权限来决定模块是否该渲染<br>设置好路由的权限</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;设置好每个功能项权限的级别&lt;br&gt;对请求的用户数据存储到loaclStorage&lt;br&gt;根据用户的权限来决定模块是否该渲染&lt;br&gt;设置好路由的权限&lt;/p&gt;
&lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
      
    
    </summary>
    
    
      <category term="protfolio" scheme="http://yoursite.com/categories/protfolio/"/>
    
    
      <category term="protflio" scheme="http://yoursite.com/tags/protflio/"/>
    
  </entry>
  
  <entry>
    <title>怎么判断对象和数组</title>
    <link href="http://yoursite.com/js/bj/%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/js/bj/%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2018-09-08T13:48:39.000Z</published>
    <updated>2020-07-10T02:17:29.436Z</updated>
    
    <content type="html"><![CDATA[<p>1、<br>instanceof判断对象的原型链是否是指向构造函数的prototype</p><p>2、对象的constructor属性 </p><p>3、<br>Object.prototype.toString.call(arr)<br>利用对象的toString可以准确判断是什么类型，call()改变this指向，这里是借用Object的方法，然后有人可能会问为什么不直接用arr.toString而要借用Object的方法，</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、&lt;br&gt;instanceof判断对象的原型链是否是指向构造函数的prototype&lt;/p&gt;
&lt;p&gt;2、对象的constructor属性 &lt;/p&gt;
&lt;p&gt;3、&lt;br&gt;Object.prototype.toString.call(arr)&lt;br&gt;利用对象的toString可
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>EventLoop</title>
    <link href="http://yoursite.com/js/bj/EventLoop/"/>
    <id>http://yoursite.com/js/bj/EventLoop/</id>
    <published>2018-09-07T13:48:39.000Z</published>
    <updated>2020-07-10T02:15:29.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>由于js是单线程,只有当上一个任务完成之后才会继续完成下一个任务,如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）</p><h3 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h3><p>由于js是单线程,只有当上一个任务完成之后才会继续完成下一个任务,如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）</p><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p>不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>主线程从任务队列中读取事件,这个过程是不断循环的,所以整个的运行机制称为event loop</p><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><p>每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行,每一个宏任务会从头到尾将这个任务执行完毕，不会执行其它）包括整体代码script，setTimeout，setInterval</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>可以理解是在当前 task 执行结束后立即执行的任务 包括Promise，process.nextTick</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h3&gt;&lt;p&gt;由于js是单线程,只有当上一个任务完成之后才会继续完成下一个任务,如果前一个任务耗时很长，后一个任务就不得不一直等着。&lt;br&gt;于是，所有任务
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>ajax/fetch/axios的区别</title>
    <link href="http://yoursite.com/js/bj/fetchAxiosAjax%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/js/bj/fetchAxiosAjax%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-09-07T13:48:39.000Z</published>
    <updated>2020-07-10T02:12:37.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ajax-fetch-axios的区别"><a href="#ajax-fetch-axios的区别" class="headerlink" title="ajax/fetch/axios的区别"></a>ajax/fetch/axios的区别</h1><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>ajax多个请求之间如果有先后关系的话，就会出现回调地狱<br>1.本身是针对MVC的编程,不符合现在前端MVVM的浪潮<br>2.基于原生的XHR开发，XHR本身的架构不清晰。</p><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>1）<code>fetch</code>只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，<code>fetch</code> 才会被<code>reject</code>。<br>2）<code>fetch</code>默认不会带<code>cookie</code>，需要添加配置项： <code>fetch(url, {credentials: 'include'})</code><br>3）fetch不支持<code>abort</code>，不支持超时控制，使用<code>setTimeout</code>及<code>Promise.reject</code>的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费<br>4）fetch没有办法原生监测请求的进度，而<code>XHR</code>可以</p><p>优点：fetch的优点：<br>1.符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里<br>2.更好更方便的写法</p><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><p><code>Axsio</code>:从浏览器中创建 <code>XMLHttpRequest</code><br>2.支持 <code>Promise API</code><br>3.客户端支持防止<code>CSRF</code><br>4.提供了一些并发请求的接口（重要，方便了很多的操作）<br>5.从 <code>node.js</code> 创建<code>http</code> 请求<br>6.拦截请求和响应<br>7.转换请求和响应数据<br>8.取消请求<br>9.自动转换JSON数据</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ajax-fetch-axios的区别&quot;&gt;&lt;a href=&quot;#ajax-fetch-axios的区别&quot; class=&quot;headerlink&quot; title=&quot;ajax/fetch/axios的区别&quot;&gt;&lt;/a&gt;ajax/fetch/axios的区别&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
  </entry>
  
  <entry>
    <title>跨域的解决方案</title>
    <link href="http://yoursite.com/chome/%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/chome/%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2018-07-09T16:51:01.000Z</published>
    <updated>2020-07-10T03:06:19.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是跨域？为什么浏览器要使用同源策略？"><a href="#什么是跨域？为什么浏览器要使用同源策略？" class="headerlink" title="什么是跨域？为什么浏览器要使用同源策略？"></a>什么是跨域？为什么浏览器要使用同源策略？</h1><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败</p><p><strong>那么是出于什么安全考虑才会引入这种机制呢</strong> 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。</p><p>也就是说，没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得你的任何信息。当然跨域并不能完全阻止 CSRF。</p><p><strong>然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？</strong> 请求必然是发出去了，但是浏览器拦截了响应。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。</p><p>接下来我们将来学习几种常见的方式来解决跨域的问题。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP 的原理很简单，就是利用<br> <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。</p><pre><code class="bash">&lt;script src=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;&lt;/script&gt;&lt;script&gt;    <span class="keyword">function</span> jsonp(data) {        console.log(data)    }&lt;/script&gt;    </code></pre><p>JSONP 使用简单且兼容性不错，但是只限于 <code>get</code> 请求。</p><p>在开发中可能会遇到多个 <code>JSONP</code> 请求的回调函数名是相同的，这时候就需要自己封装一个 <code>JSONP</code>，以下是简单实现</p><pre><code class="bash"><span class="keyword">function</span> jsonp(url, jsonpCallback, success) {  <span class="built_in">let</span> script = document.createElement(<span class="string">'script'</span>)  script.src = url  script.async = <span class="literal">true</span>  script.type = <span class="string">'text/javascript'</span>  window[jsonpCallback] = <span class="keyword">function</span>(data) {    success &amp;&amp; success(data)  }  document.body.appendChild(script)}jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="keyword">function</span>(value) {  console.log(value)})</code></pre><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 <code>XDomainRequest</code> 来实现。</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。</p><p>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</p><p>虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</p><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>以 Ajax 为例，当满足以下条件时，会触发简单请求</p><p>1、使用下列方法之一：<br><font color="red"></font></p><font color="red"><ul><li><p>GET</p></li><li><p>HEAD</p></li><li><p>POST</p></li></ul></font><p>2、Content-Type 的值仅限于下列三者之一：<br><font color="red"></font></p><font color="red"><ul><li><p>text/plain</p></li><li><p>multipart/form-data</p></li><li><p>application/x-www-form-urlencoded</p></li></ul></font><p>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器；<code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问。</p><p>复杂请求<br>那么很显然，不符合以上条件的请求就肯定是复杂请求了。</p><p>对于复杂请求来说，首先会发起一个预检请求，该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。</p><p>对于预检请求来说，如果你使用过 Node 来设置 CORS 的话，可能会遇到过这么一个坑。</p><p>以下以 express 框架举例：</p><pre><code class="bash">app.use((req, res, next) =&gt; {  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT, GET, POST, DELETE, OPTIONS'</span>)  res.header(    <span class="string">'Access-Control-Allow-Headers'</span>,    <span class="string">'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials'</span>  )  next()})</code></pre><p>该请求会验证你的 <code>Authorization</code> 字段，没有的话就会报错。</p><p>当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 <code>next</code> 方法，因为预检请求并不包含 <code>Authorization</code> 字段，所以服务端会报错。</p><p>想解决这个问题很简单，只需要在回调中过滤<code>option</code> 方法即可</p><pre><code class="bash">res.statusCode = 204res.setHeader(<span class="string">'Content-Length'</span>, <span class="string">'0'</span>)res.end()</code></pre><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和<code>b.test.com</code> 适用于该方式。</p><p>只需要给页面添加 <code>document.domain = 'test.com'</code>表示二级域名都相同就可以实现跨域</p><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p><pre><code class="bash">// 发送消息端window.parent.postMessage(<span class="string">'message'</span>, <span class="string">'http://test.com'</span>)// 接收消息端var mc = new MessageChannel()mc.addEventListener(<span class="string">'message'</span>, event =&gt; {  var origin = event.origin || event.originalEvent.origin  <span class="keyword">if</span> (origin === <span class="string">'http://test.com'</span>) {    console.log(<span class="string">'验证通过'</span>)  }})</code></pre><pre><code class="bash"></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是跨域？为什么浏览器要使用同源策略？&quot;&gt;&lt;a href=&quot;#什么是跨域？为什么浏览器要使用同源策略？&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域？为什么浏览器要使用同源策略？&quot;&gt;&lt;/a&gt;什么是跨域？为什么浏览器要使用同源策略？&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="chome" scheme="http://yoursite.com/categories/chome/"/>
    
    
  </entry>
  
  <entry>
    <title>经典布局的实现</title>
    <link href="http://yoursite.com/css/%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/css/%E7%BB%8F%E5%85%B8%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2018-07-09T02:55:31.000Z</published>
    <updated>2020-07-10T03:05:26.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左定右定中自适应"><a href="#左定右定中自适应" class="headerlink" title="左定右定中自适应"></a>左定右定中自适应</h1><p><font color="red">圣杯布局</font></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">html部分：</span><br><span class="line">html{</span><br><span class="line">    &lt;div class=<span class="string">'container clearfix'</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">'center'</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">'left'</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">'right'</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">css部分:</span><br><span class="line"> body{</span><br><span class="line">     100% overflow:hidden</span><br><span class="line"> }</span><br><span class="line">.container{</span><br><span class="line">        height:100%;</span><br><span class="line">        padding:0 200px </span><br><span class="line">        &lt;!--(200px等于左右2边的宽度)  --&gt;</span><br><span class="line">    }</span><br><span class="line">.center{</span><br><span class="line">            width:100%;</span><br><span class="line">            min-height:200px</span><br><span class="line">        }</span><br><span class="line">.left,.right{</span><br><span class="line">        width：200px;</span><br><span class="line">        height:200px</span><br><span class="line">    }</span><br><span class="line">.left,.right,.center{</span><br><span class="line">         <span class="built_in">float</span>:left</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">.left{</span><br><span class="line">    margin-left:-100%;</span><br><span class="line">    &lt;!-- (相对之前的位置定位) --&gt;</span><br><span class="line">    position:reative;</span><br><span class="line">    left:-200px;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><font color="red">双飞翼布局</font></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">html部分：</span><br><span class="line">html {</span><br><span class="line">    &lt;div class=<span class="string">'container'</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">'center'</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">'left'</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">'right'</span>&gt;&lt;/div&gt;</span><br><span class="line">css部分：</span><br><span class="line"> body{</span><br><span class="line">     100% overflow:hidden</span><br><span class="line"> }</span><br><span class="line">.container, .left .right{</span><br><span class="line">    <span class="built_in">float</span>:left;</span><br><span class="line">}</span><br><span class="line">.container{</span><br><span class="line">    width:100%;</span><br><span class="line">    padding:0 200px</span><br><span class="line">}</span><br><span class="line">.container .center{</span><br><span class="line">    margin:0 200px;</span><br><span class="line">    min-height:400px;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">.left .right{</span><br><span class="line">    width:200px</span><br><span class="line">    height:200px</span><br><span class="line">}</span><br><span class="line">.left{</span><br><span class="line">    margin-left:-100%</span><br><span class="line">}</span><br><span class="line">.right{</span><br><span class="line">    margin-left:-200px</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><font color="red">CALC</font></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.center{</span><br><span class="line">width:calc(100%-400px)</span><br><span class="line">(计算的)</span><br><span class="line">min-height:400px</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><font color="red">flex</font></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">html{</span><br><span class="line">    &lt;div class=<span class="string">'container'</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">'center'</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">'left'</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">'right'</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">css</span><br><span class="line">.container{</span><br><span class="line">    display:flex</span><br><span class="line">    justify-content:space-between</span><br><span class="line">    height:100%</span><br><span class="line">}</span><br><span class="line">.left, .right{</span><br><span class="line">    flex:0 0 200px</span><br><span class="line">    height:200px</span><br><span class="line">}</span><br><span class="line">.center{</span><br><span class="line">    flex:1</span><br><span class="line">    min-height:400px</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><font color="red">定位实现</font></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">定位实现</span><br><span class="line"> &lt;div class=<span class="string">'container'</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">'center'</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">'left'</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">'right'</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">css</span><br><span class="line">.container{</span><br><span class="line">    height:100% </span><br><span class="line">}</span><br><span class="line">.left, .right{</span><br><span class="line">    posiotion:absolute;</span><br><span class="line">    top:0;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:100px</span><br><span class="line">}</span><br><span class="line">.left{</span><br><span class="line">    left:0</span><br><span class="line">}</span><br><span class="line">.right{</span><br><span class="line">    right:0</span><br><span class="line">}</span><br><span class="line">.center{</span><br><span class="line">    margin:0 200px;</span><br><span class="line">    height:400px</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>后续如还有将继续补充</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;左定右定中自适应&quot;&gt;&lt;a href=&quot;#左定右定中自适应&quot; class=&quot;headerlink&quot; title=&quot;左定右定中自适应&quot;&gt;&lt;/a&gt;左定右定中自适应&lt;/h1&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;圣杯布局&lt;/font&gt;&lt;/p&gt;
&lt;figure clas
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="布局" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>常见的布局方案有那些呢？</title>
    <link href="http://yoursite.com/css/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88%E6%9C%89%E9%82%A3%E4%BA%9B%E5%91%A2%EF%BC%9F/"/>
    <id>http://yoursite.com/css/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%B9%E6%A1%88%E6%9C%89%E9%82%A3%E4%BA%9B%E5%91%A2%EF%BC%9F/</id>
    <published>2018-07-08T23:55:31.000Z</published>
    <updated>2020-07-08T01:15:11.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="css布局"><a href="#css布局" class="headerlink" title="css布局"></a>css布局</h1><p><font color="red"><a href="https://anne-jia.github.io/bj/经典布局的实现.html/" target="_blank" rel="noopener">经典布局的方案</a></font></p><p><code>**常见的布局方案**</code></p><p><font color="red">1. 多列布局</font></p><p><font color="red">2. 瀑布布局 waterfall flow</font></p><p>瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格.</p><p>特点：</p><p>琳琅满目：整版以图篇为主，大小不一的图片按照一定的规律排序</p><p>唯美：图片的风格以唯美的图片位置。</p><p>操作简单：浏览网站只需要轻轻滑动一下鼠标滚轮。<br><font color="red">3. 固定布局</font></p><p>以像素作为页面的基本单位，不会根据设备适应宽高。<br><font color="red">4. 可切换的固定布局</font></p><p>同样以像素作为页面单位，参考主流设备尺寸，设计几套不同宽度的布局。通过识别的屏幕尺寸或浏览器宽度，选择最合适的那套宽度布局；<br><font color="red">5. 响应布局</font></p><p>对页面进行响应式的设计实现，需要对相同内容进行不同宽度的布局设计，</p><p>有两种方式：pc优先（从pc端开始向下设计）；移动优先（从移动端向上设计）；</p><p>无论基于那种模式的设计，要兼容所有设备，布局响应时不可避免地需要对模块布局做一些变化（发生布局改变的临界点称之为断点），<br><font color="red">6. 弹性布局</font></p><p>以百分比作为页面的基本单位，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；<br><font color="red">7. 混合布局</font></p><p>同弹性布局类似，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；</p><p><span style="background-color: rgb(255, 250, 165);"><u>只是混合像素、和百分比两种单位作为页面单位。</u></span></p><p><code>**table布局和HTML+CSS布局(DIV+CSS)优缺点：**</code></p><p><span style="color: rgb(235, 0, 115);">table表格布局</span></p><p>优点：布局容易、快捷、兼容性好。</p><p>缺点：改动不便，需重新调整，工作量大。</p><p><span style="color: rgb(235, 0, 115);">DIV+CSS。</span></p><p>优点：布局灵活、改动方便。</p><p>缺点：需考虑平台的兼容性，对制作人员技能要求较高。</p><p><span style="color: rgb(235, 0, 115);">PC及移动端页面适配方法</span></p><p>设备屏幕有多种不同的分辨率，</p><h1 id="页面适配方案有如下几种："><a href="#页面适配方案有如下几种：" class="headerlink" title="页面适配方案有如下几种："></a>页面适配方案有如下几种：</h1><p><strong>1、全适配：</strong><br>响应式布局+流体布局</p><p><strong>2、移动端适配：</strong></p><p>流体布局+少量响应式</p><p>基于rem的布局（等比缩放）</p><p>流体布局</p><p>弹性布局</p><p>_<u>流式布局：</u>_</p><p>就是百分比布局，非固定像素，内容向两侧填充，理解成流动的布局，称为流式布局/</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;css布局&quot;&gt;&lt;a href=&quot;#css布局&quot; class=&quot;headerlink&quot; title=&quot;css布局&quot;&gt;&lt;/a&gt;css布局&lt;/h1&gt;&lt;p&gt;&lt;font color=&quot;red&quot;&gt;&lt;a href=&quot;https://anne-jia.github.io/bj/经
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="布局" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>JS调取电脑本地客户端发送邮件——mailto</title>
    <link href="http://yoursite.com/js/bj/js%E8%B0%83%E7%94%B5%E8%84%91%E7%9A%84%E9%82%AE%E7%AE%B1%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/js/bj/js%E8%B0%83%E7%94%B5%E8%84%91%E7%9A%84%E9%82%AE%E7%AE%B1%E6%8E%A5%E5%8F%A3/</id>
    <published>2018-07-08T23:55:31.000Z</published>
    <updated>2020-07-08T15:30:48.746Z</updated>
    
    <content type="html"><![CDATA[<p>一开始自己也是一点都没有思路呢！网上搜索一下如此简单！！！怪自己知道太少！！！见识有点少哈<br>先说一下基本语法结构：</p><p><a href="mailto:sample@163.com">send email</a></p><p>然后我们可以添加</p><p><a href="mailto:sample@163.com?subject=test&amp;cc=sample@hotmail.com&amp;body=use mailto sample">send mail</a><br>这样我们就可以基本使用邮箱的功能了。</p><p>然后我们可以通过js控制这些参数，可以让我们自由的发送邮件</p><table><thead><tr><th>属性</th><th>含有</th><th>参数</th></tr></thead><tbody><tr><td>to</td><td>收信人</td><td><a href="mailto:sample@163.com">sample@163.com</a></td></tr><tr><td>suject</td><td>主题</td><td>test</td></tr><tr><td>cc</td><td>抄送</td><td><a href="mailto:sample@hotmail.com">sample@hotmail.com</a></td></tr><tr><td>bcc</td><td>暗抄送</td><td></td></tr><tr><td>body</td><td>内容</td><td>use mailto sample</td></tr></tbody></table><p>代码：</p><pre><code class="bash">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.0 Transitional//EN"</span>&gt;&lt;HTML&gt; &lt;HEAD&gt;  &lt;TITLE&gt; Send Email &lt;/TITLE&gt;  &lt;META NAME=<span class="string">"Generator"</span> CONTENT=<span class="string">"EditPlus"</span>&gt;  &lt;META NAME=<span class="string">"Author"</span> CONTENT=<span class="string">""</span>&gt;  &lt;META NAME=<span class="string">"Keywords"</span> CONTENT=<span class="string">""</span>&gt;  &lt;META NAME=<span class="string">"Description"</span> CONTENT=<span class="string">""</span>&gt; &lt;/HEAD&gt;&lt;script&gt;Date.prototype.toString=<span class="keyword">function</span>(){    var d = new Date();    var ret = d.getYear();    var m = d.getMonth()+1;    ret+=m.length&gt;1?m:<span class="string">'0'</span>+m;    var date= d.getDate();    ret+=date.length&gt;1?date:<span class="string">'0'</span>+date;    <span class="built_in">return</span> ret;    }var initSubject=<span class="string">'test'</span>+new Date().toString(),initTo=<span class="string">'sample@163.com'</span>,initCC=<span class="string">'sample@hotmail.com'</span>,initBody=<span class="string">'use mailto sample'</span>;<span class="keyword">function</span> submitHandler(){    var subject = subText.value;    var to = toText.value;    var cc = ccText.value;    var body = bodyText.value;    mailTo.href=<span class="string">"mailto:"</span>+to+<span class="string">"?cc="</span>+cc+<span class="string">"&amp;subject="</span>+subject+<span class="string">"&amp;body="</span>+body;    mailTo.click();}<span class="keyword">function</span> init(){    subText.value=initSubject;    toText.value=initTo;    ccText.value=initCC;    bodyText.value=initBody;}&lt;/script&gt;&lt;style&gt;.label{font-weight:bold;postion:absolute;width:80px;}.head{font-color:black;font-weight:bold;}.bd{<span class="built_in">float</span>:left;width:77px;font-weight:bold;}&lt;/style&gt; &lt;BODY οnlοad=<span class="string">"init()"</span>&gt; &lt;div class=<span class="string">"head"</span>&gt;Use mailto Send Email&lt;/div&gt; &lt;div&gt; &lt;span class=<span class="string">"label"</span>&gt;Subject:&lt;/span&gt;&lt;input id=<span class="string">"subText"</span> <span class="built_in">type</span>=<span class="string">"text"</span> size=50 value=<span class="string">"TM V14.2 Bug Fix Questions_20080221"</span>&gt; &lt;/div&gt; &lt;div&gt; &lt;span class=<span class="string">"label"</span>&gt;To:&lt;/span&gt;&lt;input id=<span class="string">"toText"</span> <span class="built_in">type</span>=<span class="string">"text"</span> size=50 value=<span class="string">""</span>&gt; &lt;/div&gt; &lt;div&gt; &lt;span class=<span class="string">"label"</span>&gt;CC:&lt;/span&gt;&lt;input id=<span class="string">"ccText"</span> <span class="built_in">type</span>=<span class="string">"text"</span> size=50 value=<span class="string">""</span>&gt; &lt;/div&gt; &lt;div&gt; &lt;span class=<span class="string">"bd"</span>&gt;Body:&lt;/span&gt;&lt;textarea id=<span class="string">"bodyText"</span> rows=20 cols=100&gt;&lt;/textarea&gt;  &lt;/div&gt; &lt;input name=<span class="string">"btSend"</span> <span class="built_in">type</span>=<span class="string">"button"</span> value=<span class="string">"send email"</span> οnclick=<span class="string">"submitHandler();"</span>&gt; &lt;a href=<span class="string">"mailto:"</span> id=<span class="string">"mailTo"</span>&gt;&lt;/a&gt; &lt;/BODY&gt;&lt;/HTML&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一开始自己也是一点都没有思路呢！网上搜索一下如此简单！！！怪自己知道太少！！！见识有点少哈&lt;br&gt;先说一下基本语法结构：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;mailto:sample@163.com&quot;&gt;send email&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后我们可以添加&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="布局" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
</feed>
